## 이진 탐색
- 🔥 소스코드
```java
    public static int binarySearch(int[] arr, int target, int start, int end) {
        while (start <= end) {
            int mid = (start + end) / 2;
            if (arr[mid] == target) return mid;
            else if (arr[mid] > target) end = mid -1;
            else start = mid + 1;
        }
        return -1;
    }
```
- 순차 탐색
  - 의미: 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법
  - 사용처: 보통 정렬되지 않은 리스트에서
  - 시간 복잡도: O(N)
- 분할 정복: 탐색 공간을 특정 기준에 따라 나누고, 나눈 각 탐색 공간에서 탐색을 이어나가는 것
- 이진 탐색
  - 의미: 찾으려는 데이터(target)와 중간점 위치에 있는 데이터(mid)를 반복적으로 비교해서 원하는 데이터를 찾는 방법
  - 사용처: 보통 정렬된 리스트에서, 탐색 범위가 큰 상황에서(ex. 10억) (큰 수를 보면 당연하듯이 가장 먼저 이진 탐색을 떠올릴 것!)
  - 요소: 변수 3개 이용(start, mid, end)
  - 시간 복잡도: O(logN)
  - 구현: 재귀 함수 혹은 반복문을 사용
  - '파라메트릭 서치' 유형 해결 가능
    - 의미: 최적화 문제를 결정 문제로 바꾸어 해결하는 기법
    - 결정 문제: 예 혹은 아니오로 답하는 문제
    - 사용처: 원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제 (가장 큰, 가장 작은 등 최적화 요구)
  - 자바 내장 메서드
    - 🔥🔥 Arrays.binarySearch(arr, target);
    - 🔥🔥 Collections.binarySearch(list, target);



## 이진 탐색 문제 피드백
### [수 찾기](백준/Silver/1920. 수 찾기)
- 런타임 에러 나오면 하나하나 눌러서 살펴봐야 할듯. 지금은 이분 탐색에 익숙하지 않아서 이 자체에 문제가 있을 거라 생각함.
- 문제 처음 읽을 때 숫자 범위 체크하는 거 놓치지 말자!! Int, long
  
### [랜선 자르기](백준/Silver/1654. 랜선 자르기)
- 실수1: n개보다 많은 경우도 정답 처리 하는 거 놓침.
  - 문제 똑바로 읽자..!!
  - 🔥 처음에 이해 안 되는 부분 쑥쑥 넘기는 거 좋은데, 다 읽은 다음 다시 읽어봐야 해!!!
- 실수2: end를 잘못 설정함. (설계할 때 극단적인 경우 고려하지 않음.)
  - 처음 문제 설계할 때 일반적인 경우 따진 다음, 특별한 경우까지 꼭 따져라!!!
  - 특히 제시된 예시가 제한적이라면, 더욱 적극적으로 임해야 한다.
- 실수3: 런타임 에러일 때 극단적 케이스 고려하지 않음.
  - 런타임 에러 뜨면 극단적인 케이스, 자체 오류 생각해보자.
- 실수4: 자료형 범위 제대로 따지지 않음.
  - 🔥 단지 제시된 숫자가 int 범위 안이라고 해서 그냥 넘어가면 안 됨. 이들끼리 더했을 때 넘을 수도 있음.
  - 자료형 범위 넘어갔을 때 틀렸습니다라고 뜨네.

### [나무 자르기](백준/Silver/2805. 나무 자르기)
- 굳이 정답 후보 int result 따로 선언하지 않아도 됨. 마지막 end가 답임.
- long 신경 써야지!!!

### [입국심사]프로그래머스
- 숫자가 너무 커서 이진탐색 해야 함.
- '결과적으로' 봤을 때 정해진 시간동안 효율 좋은 놈이 제일 많이 일해야 함. 
  - 🔥🔥 순차적 사고도 좋지만, 결과적 사고도 하자!!! (특히, 현재 시간 복잡도가 크다면)