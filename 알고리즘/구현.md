## 구현
- 의미: 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
- 유형: 완전 탐색과 시뮬레이션 모두 구현의 핵심이 되는 경우가 많음.
  - 완전 탐색: 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
  - 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행
- 피지컬: 구현 문제는 언어의 문법에 능숙하고 코드 작성 속도가 빨라야 함.

## 구현 문제 풀이 피드백
### 이코테 예제 문제(왕실의 나이트)
- 정수형 자료형의 범위: int < long
- continue: 반복문에서 현재 단계의 실행을 멈춤 (cf. break)
- 내가 문제를 푸는 게 아니야! 컴퓨터가 문제를 풀게 해야 해. 컴퓨터가 일반화를 하게 해야 해.
- 2차원 공간에서 이동해야 한다면, 이동할 수 있는 경우의 수를 dx(행), dy(열) 배열 형태로 저장하고 for문 돌리자.

### 이코테 예제 문제(게임 개발)
- 2차원 공간에서 이동하는 경우
    - dx, dy, direction 배열로 저장해두기
    - 예: nx = x + dx[direction[i]];
- indexOf는 list에서만 쓸 수 있음.
- 🔥 리스트 선언
```java
List<String> s2 = new ArrayList<String>(Arrays.asList("1", "2", "3")); // 원소 자유롭게 수정 가능 🔥 
List<String> s5 = Arrays.asList("1", "2", "3"); // set을 통해서만 수정 가능
List<String> s5 = List.of("1", "2", "3"); // 수정 불가능
```


### [스킬트리](프로그래머스/2/49993. 스킬트리)
- 아이디어 조금만 더 구체화하려고 노력하자. 직접 손글씨 쓰는 것도 꺼리지 말자. 
- 메서드 구체화도 해보면 좋을 듯. (순수구현이라면)
- String 문자열 비교 헷갈리지마!! equals로 체크해야해!!
- 배열에서는 contains 지원하지 않는다!
- 스트림 이용해서 함수형 프로그래밍 하는 거 좋지만, 성능은 보장 못함. for 문으로도 구현할 줄 알아야 함.
- 메서드 참조: 람다식을 더 간단히 표현하게 해주는 문법
  - 정적 메서드 참조
  - Object 인스턴스 메서드 참조
  - 특정 타입(클래스)에 대한 인스턴스 메서드에 대한 메서드 참조
  - 생성자 참조
- 🔥 s.replaceAll("[^" + skill + "]", ""); // a, b, c 셋 중에 하나가 아니라면 replace 작동함.

### [키패드 누르기](프로그래머스/1/67256. ［카카오 인턴］ 키패드 누르기)
- 처음에 변수 선언할 때 main메서드 안에만 선언하려고 하지 말기, class 필드 변수도 고려해라!
- 사람을 객체로 설정하고 풀 수도 있다. 객체지향적으로!

### [뱀](백준/Gold/3190. 뱀)
- deque로 뱀 표현하면 굿.
- List<int[]> list = new ArrayList<>();
  - 🔥 주의: 위와 같은 자료 구조에서는 특정 int[] 배열이 있는지 확인하기 위해서 단순히 contains를 사용할 수 없다!! 메모리 주소가 비교되기 때문에 당연히 다 다를 수밖에 없어.
  - 하려면 직접 비교해야 해. 그리고 직접 비교하지 않는 방법은.. int[]가 좌표라면 map에 별도로 표시를 해서 map[x][y]로 check할 수 있음. 방문 처리하는 것처럼.
- 주의: 이중 반복문에서 break;하면 내부 반복문만 취소된다!!
  - 외부 반복문까지 break 하고 싶다면, boolean 활용하거나, 아래와 같이 레이블 활용.
  ```java
        outerLoop: // 외부 반복문에 레이블 "outerLoop" 지정 🔥 
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 5; j++) {
                if (조건을 만족하는 경우) {
                    break outerLoop; // 레이블을 사용하여 외부 반복문까지 중단
                }
            }
        }
  ```
  - 🔥 break; 사용할 때 범위까지 체크하자!!
- 문제에서 특정 로직 순서를 제시해줬다면, 웬만하면 그대로 따라가자!
- dx, dy 헷갈리지 말고 방향 차분히 체크하자

### [로봇 청소기](백준/Gold/14503. 로봇 청소기)
- 뱀과 유사문제.
- 제출 3번과 4번의 차이점 분석하기. 왜 벗어나는 걸 추가해줬는데 틀리지? 불필요한건 알겠는데, 틀리는 거에 영향을 주진 않을 것 같은데..
- 로봇을 class로 구현할 수도 있음.
  




## 완전 탐색 문제 풀이 피드백
### [모의고사](프로그래머스/Lv.1/42840. 모의고사)
- 자바의 타입
    - 기본 타입(primitive type)
        - 정수 타입: byte, char, short, int, long
        - 🔥 실수 타입: float, double
        - 논리 타입: boolean
    - 참조 타입(reference type)
        - 배열 타입
        - 열거 타입(enum)
        - 클래스 (ex. String, Integer)
        - 인터페이스
    - 차이점: 기본 타입은 실제 값을 변수 안에 저장하지만, 참조 타입은 메모리의 번지를 저장함.
- 리스트, 배열 변환 (stream 이용) (for문, Arrays.asList 등을 이용할 수도 있음.)
```java
// IntegerList to intArray
int[] intArray = IntegerList.stream()
                            .mapToInt(Integer::intValue)
                            .toArray();

// intArray to IntegerList
List<Integer> integerList = Arrays.stream(intArray)
                                   .boxed() // int to Integer
                                   .collect(Collectors.toList());

// StringList to StringArr
String[] stringArray = stringList.toArray(new String[0]);

// StringArr to StringList
List<String> stringList = Arrays.stream(stringArray)
                                        .collect(Collectors.toList());
```
- 배열/리스트 최댓값 구하기
```java
int max = Arrays.stream(intArray).max().getAsInt(); 🔥 
// max는 OptionalInt 객체로 반환. getAsInt는 해당 객체에서 실제 int값을 가져옴.
// OptionalInt는 Java 8부터 추가된 클래스로, 값이 존재할 수도 있고 없을 수도 있는 값을 감싸는 래퍼 클래스
int max = Collections.max(intList);
```
- 스트림 문법
    - 의미: 자바8에서 등장한 새로운 기술 중의 하나로, 컬렉션을 함수형 프로그래밍 스타일로 다룰 수 있게 해주는 API
    - 스트림 연산
        - 중간 연산
        - 최종 연산
- Collection(인터페이스): list, set, map
- Collections(유틸리티 클래스): 컬렉션을 위한 유용한 메서드 제공
- Collectors: 스트림 문법


### [카펫](프로그래머스/Lv.2/42842. 카펫)
- import java.util.*; 하고 시작하자!!
- 2차원 리스트 선언
```java
List<List<Integer>> list1 = new ArrayList<>();
```

### [수식 최대화](프로그래머스/Lv.2/67257. ［카카오 인턴］ 수식 최대화)
- 🔥 문자열에 특정 문자가 포함되었는지 확인하고 싶다면 -> str.contains("dd");
- 네이밍 조금만 더 신경쓰자. 
- 🔥 **문제 읽을 때 숫자 범위 체크하고 int, long 골라서 사용하자.**
  - 2,147,483,647 넘어가거나 2의 31제곱 넘어갈 때
  - 2,147,483,648 이하이거나 2의 31제곱 -1 이하일 때
- 길이 확인 메서드
```java
int l1 = string.length();
int l2 = list.size();
int l3 = array.length;
```
- Integer.toString(int): int to string
- 문자열끼리 비교하는 거 주의하자!!!(문자열은 클래스야!) str1.equals(str2)
- 🔥 StringTokenizer 학습 (문자열 분할할 때 완전 유용!)
```java
StringTokenizer st = new StringTokenizer(expression, "+-*", true); 
// "+", "-". "*"을 각각으로 구분자 취급하여 분할함. 
// 구분자를 토큰에 포함할 것인지 설정할 수 있음.
List<String> tokens = new ArrayList<>();
while (st.hasMoreTokens()) {
    tokens.add(st.nextToken());
}
```
- for 문에서 제한 조건을 리스트 size로 제한했지만 중간에 리스트 요소를 삭제하거나 추가한다면, i 업데이트 시켜주기!!


### [체스판 다시 칠하기](백준/Silver/1018. 체스판 다시 칠하기)
- st = new StringTokenizer(br.readLine(), ""); // 이렇게 해도 하나의 문자열로 처리됨. (공백없는 입력)
- 배열, 리스트 등 하나의 메모리 주소를 공유하면, 값을 바꾸는 것 조심해야 함. 원본을 가지고 싶다면 복사 잘 해둬야 해.
- 구현은 문제를 정말 잘 읽고 설계를 꼼꼼히 하는 게 중요하다!!!
  - 중간 중간 로그 찍어보고
  - 급하지 않고 차분하게
- 문제: 2로 처리해두는 게 아니라 바로 체크해볼 수도 있을 듯.

### [영화 감독 숌](백준/Silver/1436. 영화감독 숌)
- "연속으로" 이를 빼먹고 구현함. 문제 두 번 체킹하는 거 잊지말자!!! 하나라도 놓치면 치명적일 수 있다. 
- 🔥 int에서 각 자릿수 얻는 방법
```java
    while (number > 0) {
      stack.push(number % 10);
      number /= 10;
    }
```
- 더 효율적인 풀이가 있을 것으로 예상되나, 가성비가 없을 것 같아 패스. 다음에 살펴보기.


### [피로도](프로그래머스/2/87946. 피로도)
- 순열 알고리즘 -> visited 활용해서 겹치는 index는 넘기면 됨!!
- 해당 문제 바로 dfs로 해결할 수 있었음. (index정해두고 가는 게 아니라 실시간으로 갈 수 있음.) 다음 풀이는 깔끔하게 dfs로 풀어보기
  

### [신고 결과 받기](프로그래머스/1/92334. 신고 결과 받기)
- 🔥 set 값 읽으려면
  - List<> list = new ArrayList<set>();

### [k진수에서 소수 개수 구하기](프로그래머스/2/92335. k진수에서 소수 개수 구하기)
- 🔥 10진법 -> x진법: Integer.toString(n, x); (반대는 parse)
- 🔥 Long.parseLong(c)도 있음!! (진법 변환했다가 다시 돌아올 때 조심해야 해! 숫자 커질 수 있음.)
- 소수 찾기
  - 🔥 해당 수의 가장 큰 약수까지만 고려해도 된다!
```java
    public static boolean isPrime(long n) {
        if (n == 1) return false;
        for (int i = 2; i <= Math.sqrt(n); i++) { 
            if (n % i == 0) return false;
        }
        
        return true;
    }
```
- 🔥 연속된 특정 수, 문자를 삭제하고 싶을 때
  - "1002".split("0");
    - ["1", "", "2"] 빈 문자열로 처리하면 된다!
    - c.equals("") continue;
```java
import java.util.*;

class Solution {
    public int solution(int n, int k) {
        int answer = 0;
        
        for (String c : Integer.toString(n, k).split("0")) {
            if (c.equals("")) continue;
            if (isPrime(Long.parseLong(c))) answer++;
        }

        return answer;
    }
    
    public static boolean isPrime(long n) {
        if (n == 1) return false;
        for (long i = 2; i <= Math.sqrt(n); i++) { // 이유? 가장 큰 약수
            if (n % i == 0) return false;
        }
        
        return true;
    }
}
```

### [주사위 굴리기](../백준/Gold/14499. 주사위 굴리기)
- 이런 디테일한 구현을 요구하는 문제 자주 풀어봐야 할 듯.
- 실제 실행보다는 전처리가 더욱 무거운 문제.


### [톱니 바퀴](../백준/Gold/14891. 톱니바퀴)
- 시뮬레이션 같은 구현은 설계, 침착한 태도가 정말 중요함!!
- 처음에는 deque 이용하려 했으나, 중간 요소 접근해야 하는 거 도중에 알고 자료구조 바꿈.
  - 큐, 덱, 스택 쓰기 전에 중간 요소 필요없는지 점검하자.
- 제곱: Math.pow(n, 거듭제곱수);
- 공백없는 입력 구분하려면 우선 스트링으로 받고 split하거나 charAt -'0' 활용해야 함.


### [주차 요금 계산](../프로그래머스/2/92341. 주차 요금 계산)
- 처음 설계가 미흡했던 문제
  - 문제에서의 설정된 주차장 요금 계산이 아니라 내가 평소에 알고 있는 주자창 요금 계산으로 이해해버림.
  - 나름 설계를 했다고 생각했지만, 놓친 요구사항이 있었음. (개별 요금이 아니라 총 요금을 산출했어야 함.)
  - 이처럼 호흡이 긴 문제, 설명이 긴 문제에 대해서는 조급함을 덜어야 함.
  - 이런 문제일수록 원하는 요구사항에 도달하기까지의 과정을 정확하게 설계해야 함.
- 왠만하면 클래스 선언보다는 기본 자료구조로 풀자. 어색하니까.
  - 다음 풀이에서는 기본 자료구조로 풀이해보기
  - 자동 정렬되는 treemap을 활용할 수 있음. but 삽입, 삭제마다 정렬하기에 성능 hash보다는 안 좋음. 
  - 해당 풀이에서는 매번 정렬할 필요 없고 마지막에만 하면 되니까 HashMap 쓰고 Comparator 쓰는 게 좋을 듯.
- 올림: Math.ceil
  - 주의!! int형끼리 계산하면 int가 리턴되기에 바로 ceil 씌우면 소용이 없다!!
  - 해결: Math.ceil((double) time / fee[2]);
- 반올림: Math.round
  - 반올림도 마찬가지로 int형 주의하기!
  ```java
      double pie = 3.14159265;
      
      System.out.println("기존값: " + pie);				 // 3.14159265
      System.out.println("소수점 첫째자리까지 반올림: " + Math.round(pie*10)/10.0);	 // 3.1
      System.out.println("소수점 둘째자리까지 반올림: " + Math.round(pie*100)/100.0);	 // 3.14
      System.out.println("소수점 셋째자리까지 반올림: " + Math.round(pie*1000)/1000.00);// 3.142
  ```
- 실전에서는 익숙하지 않은 자료구조 지양하자.
  - 순서가 있는 맵 LinkedHashMap
- 깔끔하게 구현하는 게 목표가 되어서는 안 돼!!! 더럽더라도 일단 통과해야 해!!!!!!!!!!


### 