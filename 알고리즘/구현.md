## 구현
- 의미: 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
- 유형: 완전 탐색과 시뮬레이션 모두 구현의 핵심이 되는 경우가 많음.
  - 완전 탐색: 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
  - 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행
- 피지컬: 구현 문제는 언어의 문법에 능숙하고 코드 작성 속도가 빨라야 함.

## 구현 문제 풀이 피드백
### 이코테 예제 문제(왕실의 나이트)
- 정수형 자료형의 범위: int < long
- continue: 반복문에서 현재 단계의 실행을 멈춤 (cf. break)
- 내가 문제를 푸는 게 아니야! 컴퓨터가 문제를 풀게 해야 해. 컴퓨터가 일반화를 하게 해야 해.
- 2차원 공간에서 이동해야 한다면, 이동할 수 있는 경우의 수를 dx(행), dy(열) 배열 형태로 저장하고 for문 돌리자.

### 이코테 예제 문제(게임 개발)
- 2차원 공간에서 이동하는 경우
    - dx, dy, direction 배열로 저장해두기
    - 예: nx = x + dx[direction[i]];
- indexOf는 list에서만 쓸 수 있음.
- 리스트 선언
```java
List<String> s2 = new ArrayList<String>(Arrays.asList("1", "2", "3")); // 원소 자유롭게 수정 가능
List<String> s5 = Arrays.asList("1", "2", "3"); // set을 통해서만 수정 가능
List<String> s5 = List.of("1", "2", "3"); // 수정 불가능
```



## 완전 탐색 문제 풀이 피드백
### [모의고사](프로그래머스/Lv.1/42840. 모의고사)
- 자바의 타입
    - 기본 타입(primitive type)
        - 정수 타입: byte, char, short, int, long
        - 실수 타입: float, double
        - 논리 타입: boolean
    - 참조 타입(reference type)
        - 배열 타입
        - 열거 타입(enum)
        - 클래스 (ex. String, Integer)
        - 인터페이스
    - 차이점: 기본 타입은 실제 값을 변수 안에 저장하지만, 참조 타입은 메모리의 번지를 저장함.
- 리스트, 배열 변환 (stream 이용) (for문, Arrays.asList 등을 이용할 수도 있음.)
```java
// IntegerList to intArray
int[] intArray = IntegerList.stream()
                            .mapToInt(Integer::intValue)
                            .toArray();

// intArray to IntegerList
List<Integer> integerList = Arrays.stream(intArray)
                                   .boxed() // int to Integer
                                   .collect(Collectors.toList());

// StringList to StringArr
String[] stringArray = stringList.toArray(new String[0]);

// StringArr to StringList
List<String> stringList = Arrays.stream(stringArray)
                                        .collect(Collectors.toList());
```
- 배열/리스트 최댓값 구하기
```java
int max = Arrays.stream(intArray).max().getAsInt(); 
// max는 OptionalInt 객체로 반환. getAsInt는 해당 객체에서 실제 int값을 가져옴.
// OptionalInt는 Java 8부터 추가된 클래스로, 값이 존재할 수도 있고 없을 수도 있는 값을 감싸는 래퍼 클래스
int max = Collections.max(intList);
```
- 스트림 문법
    - 의미: 자바8에서 등장한 새로운 기술 중의 하나로, 컬렉션을 함수형 프로그래밍 스타일로 다룰 수 있게 해주는 API
    - 스트림 연산
        - 중간 연산
        - 최종 연산
- Collection(인터페이스): list, set, map
- Collections(유틸리티 클래스): 컬렉션을 위한 유용한 메서드 제공
- Collectors: 스트림 문법


### [카펫](프로그래머스/Lv.2/42842. 카펫)
- import java.util.*; 하고 시작하자!!
- 2차원 리스트 선언
```java
List<List<Integer>> list1 = new ArrayList<>();
```

### [수식 최대화](프로그래머스/Lv.2/67257. ［카카오 인턴］ 수식 최대화)
- 문자열에 특정 문자가 포함되었는지 확인하고 싶다면 -> str.contains("dd");
- 네이밍 조금만 더 신경쓰자. 
- **문제 읽을 때 숫자 범위 체크하고 int, long 골라서 사용하자.**
  - 2,147,483,647 넘어가거나 2의 31제곱 넘어갈 때
  - 2,147,483,648 이하이거나 2의 31제곱 -1 이하일 때
- 길이 확인 메서드
```java
int l1 = string.length();
int l2 = list.size();
int l3 = array.length;
```
- Integer.toString(int): int to string
- 문자열끼리 비교하는 거 주의하자!!!(문자열은 클래스야!) str1.equals(str2)
- StringTokenizer 학습 (문자열 분할할 때 완전 유용!)
```java
StringTokenizer st = new StringTokenizer(expression, "+-*", true); 
// "+", "-". "*"을 각각으로 구분자 취급하여 분할함. 
// 구분자를 토큰에 포함할 것인지 설정할 수 있음.
List<String> tokens = new ArrayList<>();
while (st.hasMoreTokens()) {
    tokens.add(st.nextToken());
}
```
- for 문에서 제한 조건을 리스트 size로 제한했지만 중간에 리스트 요소를 삭제하거나 추가한다면, i 업데이트 시켜주기!!