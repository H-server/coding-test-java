## 구현
- 의미: 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
- 유형: 완전 탐색과 시뮬레이션 모두 구현의 핵심이 되는 경우가 많음.
  - 완전 탐색: 모든 경우의 수를 주저 없이 다 계산하는 해결 방법
  - 시뮬레이션: 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행
- 피지컬: 구현 문제는 언어의 문법에 능숙하고 코드 작성 속도가 빨라야 함.

## 구현 문제 풀이 피드백
### 이코테 예제 문제(왕실의 나이트)
- 정수형 자료형의 범위: int < long
- continue: 반복문에서 현재 단계의 실행을 멈춤 (cf. break)
- 내가 문제를 푸는 게 아니야! 컴퓨터가 문제를 풀게 해야 해. 컴퓨터가 일반화를 하게 해야 해.
- 2차원 공간에서 이동해야 한다면, 이동할 수 있는 경우의 수를 dx(행), dy(열) 배열 형태로 저장하고 for문 돌리자.

### 이코테 예제 문제(게임 개발)
- 2차원 공간에서 이동하는 경우
    - dx, dy, direction 배열로 저장해두기
    - 예: nx = x + dx[direction[i]];
- indexOf는 list에서만 쓸 수 있음.
- 리스트 선언
```java
List<String> s2 = new ArrayList<String>(Arrays.asList("1", "2", "3")); // 원소 자유롭게 수정 가능
List<String> s5 = Arrays.asList("1", "2", "3"); // set을 통해서만 수정 가능
List<String> s5 = List.of("1", "2", "3"); // 수정 불가능
```


### [스킬트리](프로그래머스/2/49993. 스킬트리)
- 아이디어 조금만 더 구체화하려고 노력하자. 직접 손글씨 쓰는 것도 꺼리지 말자. 
- 메서드 구체화도 해보면 좋을 듯. (순수구현이라면)
- String 문자열 비교 헷갈리지마!! equals로 체크해야해!!
- 배열에서는 contains 지원하지 않는다!
- 스트림 이용해서 함수형 프로그래밍 하는 거 좋지만, 성능은 보장 못함. for 문으로도 구현할 줄 알아야 함.
- 메서드 참조: 람다식을 더 간단히 표현하게 해주는 문법
  - 정적 메서드 참조
  - Object 인스턴스 메서드 참조
  - 특정 타입(클래스)에 대한 인스턴스 메서드에 대한 메서드 참조
  - 생성자 참조
- s.replaceAll("[^" + skill + "]", ""); // a, b, c 셋 중에 하나가 아니라면 replace 작동함.

### [키패드 누르기](프로그래머스/1/67256. ［카카오 인턴］ 키패드 누르기)
- 처음에 변수 선언할 때 main메서드 안에만 선언하려고 하지 말기, class 필드 변수도 고려해라!
- 사람을 객체로 설정하고 풀 수도 있다. 객체지향적으로!
  



## 완전 탐색 문제 풀이 피드백
### [모의고사](프로그래머스/Lv.1/42840. 모의고사)
- 자바의 타입
    - 기본 타입(primitive type)
        - 정수 타입: byte, char, short, int, long
        - 실수 타입: float, double
        - 논리 타입: boolean
    - 참조 타입(reference type)
        - 배열 타입
        - 열거 타입(enum)
        - 클래스 (ex. String, Integer)
        - 인터페이스
    - 차이점: 기본 타입은 실제 값을 변수 안에 저장하지만, 참조 타입은 메모리의 번지를 저장함.
- 리스트, 배열 변환 (stream 이용) (for문, Arrays.asList 등을 이용할 수도 있음.)
```java
// IntegerList to intArray
int[] intArray = IntegerList.stream()
                            .mapToInt(Integer::intValue)
                            .toArray();

// intArray to IntegerList
List<Integer> integerList = Arrays.stream(intArray)
                                   .boxed() // int to Integer
                                   .collect(Collectors.toList());

// StringList to StringArr
String[] stringArray = stringList.toArray(new String[0]);

// StringArr to StringList
List<String> stringList = Arrays.stream(stringArray)
                                        .collect(Collectors.toList());
```
- 배열/리스트 최댓값 구하기
```java
int max = Arrays.stream(intArray).max().getAsInt(); 
// max는 OptionalInt 객체로 반환. getAsInt는 해당 객체에서 실제 int값을 가져옴.
// OptionalInt는 Java 8부터 추가된 클래스로, 값이 존재할 수도 있고 없을 수도 있는 값을 감싸는 래퍼 클래스
int max = Collections.max(intList);
```
- 스트림 문법
    - 의미: 자바8에서 등장한 새로운 기술 중의 하나로, 컬렉션을 함수형 프로그래밍 스타일로 다룰 수 있게 해주는 API
    - 스트림 연산
        - 중간 연산
        - 최종 연산
- Collection(인터페이스): list, set, map
- Collections(유틸리티 클래스): 컬렉션을 위한 유용한 메서드 제공
- Collectors: 스트림 문법


### [카펫](프로그래머스/Lv.2/42842. 카펫)
- import java.util.*; 하고 시작하자!!
- 2차원 리스트 선언
```java
List<List<Integer>> list1 = new ArrayList<>();
```

### [수식 최대화](프로그래머스/Lv.2/67257. ［카카오 인턴］ 수식 최대화)
- 문자열에 특정 문자가 포함되었는지 확인하고 싶다면 -> str.contains("dd");
- 네이밍 조금만 더 신경쓰자. 
- **문제 읽을 때 숫자 범위 체크하고 int, long 골라서 사용하자.**
  - 2,147,483,647 넘어가거나 2의 31제곱 넘어갈 때
  - 2,147,483,648 이하이거나 2의 31제곱 -1 이하일 때
- 길이 확인 메서드
```java
int l1 = string.length();
int l2 = list.size();
int l3 = array.length;
```
- Integer.toString(int): int to string
- 문자열끼리 비교하는 거 주의하자!!!(문자열은 클래스야!) str1.equals(str2)
- StringTokenizer 학습 (문자열 분할할 때 완전 유용!)
```java
StringTokenizer st = new StringTokenizer(expression, "+-*", true); 
// "+", "-". "*"을 각각으로 구분자 취급하여 분할함. 
// 구분자를 토큰에 포함할 것인지 설정할 수 있음.
List<String> tokens = new ArrayList<>();
while (st.hasMoreTokens()) {
    tokens.add(st.nextToken());
}
```
- for 문에서 제한 조건을 리스트 size로 제한했지만 중간에 리스트 요소를 삭제하거나 추가한다면, i 업데이트 시켜주기!!


### [체스판 다시 칠하기](백준/Silver/1018. 체스판 다시 칠하기)
- st = new StringTokenizer(br.readLine(), ""); // 이렇게 해도 하나의 문자열로 처리됨. (공백없는 입력)
- 배열, 리스트 등 하나의 메모리 주소를 공유하면, 값을 바꾸는 것 조심해야 함. 원본을 가지고 싶다면 복사 잘 해둬야 해.
- 구현은 문제를 정말 잘 읽고 설계를 꼼꼼히 하는 게 중요하다!!!
  - 중간 중간 로그 찍어보고
  - 급하지 않고 차분하게
- 문제: 2로 처리해두는 게 아니라 바로 체크해볼 수도 있을 듯.