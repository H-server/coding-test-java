### 백트랙킹
- 의미: 탐색 알고리즘 중의 하나로, 노드가 특정 조건을 위배했을 때 되돌아가서 다른 노드 탐색하는 알고리즘
- 가지치기(pruning): 더 이상 탐색할 필요가 없는 노드를 제외
- 특징: DFS와 유사하며, 혼용하여 사용가능함. (재귀라는 맥락을 공유)
- 어떻게 보면 DFS는 백트랙킹의 일종임. 
- 사용처
  - 순열, 조합 (가능한 모든 조합을 찾아야 할 때)
- 🔥 본질
  - 순서가 있음.
  - 문어발처럼 뻗어나감. 그리고 위에서 아래로 작동.
- 🔥 유형
  - 순열
  - 조합
  - 같순열 - 같은 것이 포함된 순열 (연산자 끼워넣기, 광물캐기) - 중복 줄이는 데 용이함.
  - [0, 0, 0] ~ [3, 3, 3] (이모티콘 할인행사)

---

## 백트랙킹 문제 풀이 피드백
### [N과M](백준/Silver/15649. N과 M （1）)
- 🔥🔥 StringBuilder.append(): 매개변수에 char,int 등 원시 자료형 들어갈 수 있다. 배열도!!! char[]도 가능!!
- 방문처리를 따로 boolean으로 처리할 수도 있음.

### [치킨 배달](../백준/Gold/15686. 치킨 배달)
- 자료구조에만 의존하지 말고, 객체지향적으로 (클래스 이용해서) 코드 짜보기. (확장성)
- 역시 설계 꼼꼼히 해야 한다.
- 백트랙킹(조합, 순열 등) 좀 더 public한 코드를 짜보자. 너무 내 주관적인 코드인 것 같음. 

### [소수 찾기](../프로그래머스/2/소수 찾기.java)
- String 길이 메서드: length()
- 조합과 순열을 복합한 문제. 역시 기본기가 중요하다. 
  - 순열에서 중복된 요소 고려하기 위해 visited 활용하는데,, 이것도 back했을 때 복구 해줘야 한다. 

### [모음 사전]()
- 🔥 Stringbuilder에서 삭제: sb.deleteCharAt(sb.length() - 1);

### [이모티콘 할인행사](../프로그래머스/2/150368. 이모티콘 할인행사) x2
- 백트랙킹도 자세하게 설계하고 들어가자.
  - depth 선정
  - 종료 조건
  - 반복문
    - 무얼 기준으로
    - 복구
- 백트랙킹에서 depth 잘못 선정하거나, for문 잘못 돌면 중복되고 종료 조건 잡기 어려울 수 있음.
  - depth를 arr의 index로 잡을 수도 있음.

- 🔥 2번째 풀이 잘한 점
  - 중간중간 해당 기능이 잘 구현됐는지 꼼꼼히 점검한 점 good
  - 코드 한 줄 한 줄 생각 담아서 짠 점 굿.
- 백트랙킹 + 약간의 구현 -> 큰 굴곡이 없다면 30분 정도 걸림.

- 🔥 이전 풀이와의 비교 
  - 첫 번째 백트랙킹이 조금 더 직관적인 듯.
    - 각 자리마다 10, 20, 30, 40 4번이 꼭 나와야 하는 걸 기준으로 함.
    - 10, 20, 30, 40 세일 배열을 기준으로 함.
    - 반복문 범위: 4 (세일의 범위 길이)
  - 🔥 두 번째 백트랙킹은 솔직히 백프로 이해는 안 됨.
    - 어렴풋이 알겠는 건, start를 제한한다는 건 '순서'를 고려하지 않겠다는 것. (조합도 그렇잖아.)
    - 반복문 시작 범위를 제한함. int i = idx; back(i); 
    - 각 이모티콘마다 40, 30, 20, 10 4번의 값을 꼭 가져야 함.
    - 반복문 범위: 이모티콘 배열의 길이
- 백트랙킹 할 때, 어떤 예상값이 나와야 하는지부터 파악해보기.
  


### [양궁대회](../프로그래머스/2/92342. 양궁대회)
- 🔥 전에 봤던 비슷한 문제랑 스트럭쳐 유사하다고 해서 우숩게 보면 큰일난다!!!!
  - 작은 detail이 바뀌면 설계 자체가 달라질 수 있다. 
- 효율성 계산
  - 어림짐작했더니 10억 10초 간당간당해서 일단 그냥 해버림. 나중에 개선하면 되겠지. 하고.
  - 좋지 않은 선택이었음. 성능 개선이 간단히 뭐 몇개 첨삭해서 되는 게 아님. 설계의 일부분 자체를 바꿔야 할 수도 있음.
  - 효율성 계산 후, 간당간당했다면 이 때 더 나은 방법을 탐색해봤어야 함. 기본 틀에서 최적화시킬 수 있는 방안을 생각해봤어야 해.
- 칭찬
  - 실패, 효율성 문제 두 개가 떴을 때, 각각에 대해서 처리한 점 good
  - 효율성, 시간 초과 문제는 근본적인 틀을 바꿔야 해. 거시적인 것(back)(시간에 가장 많은 영향을 미치는 부분)부터 본 게 잘했음.
  - 리팩토링도 설계하듯이 차분히 함. 들여쓰기 활용하면서 good
- 🔥 깊은 복사(값까지 복사, 서로 영향x), 얕은 복사(메모리 주소값만 복사)
  - 🔥🔥 원시형 타입 복사할 때는 clone() 메서드 활용!!!
  - 클래스라면 오버라이딩해야함. 이때는 그저 새로 반복문 돌게 하는 게 나을 듯.
  - ```java
      @Override // 공변 반환 타입을 이용한 오버라이딩
      public MyObject clone() throws CloneNotSupportedException {
          return (MyObject) super.clone(); 
      }
  - ```
- 설계할 때, 예시 케이스를 하나하나 자세하게 살펴보는 것도 설계하는 데 도움될 수 있다.
- 백트랙킹에서 반복문 없는 경우 피드백하기. 마지막 처리 good

- 앞에서부터 순회하는 방법도 있음. 반복문 종료조건 커스텀. 제일 마지막이 정답


### [스타트와 링크](../백준/Silver/14889. 스타트와 링크) x 2 (한번더 풀어봐. 백트랙킹 연습하기 좋은 문제)
- 🔥🔥 조합은 반복문 시작 i에 그 전 idx+1해서 넣어주면 됨. (visited 안 써도 됨. 이건 순열에서만.)
- 🔥🔥 순열 (중복순열은 visited만 제거해주면 됨.)
- ```java
  public class AlgorithmStudy {
    public static void permutation(int[] arr, int[] out, boolean[] visited, int depth, int r){
        if(depth == r){
            for(int num: out) System.out.print(num);
            System.out.println();
            return;
        }

        for(int i=0; i<arr.length; i++){
            if(!visited[i]){
                visited[i] = true;
                out[depth] = arr[i];
                permutation(arr, out, visited, depth+1, r);
                visited[i] = false;
            }
        }
    }

    public static void main(String[] args){
        int[] arr = {1, 2, 3};
        int r = 2;
        permutation(arr, new int[r], new boolean[arr.length], 0, r);
    }
  } 
- ```


- 🔥🔥 조합 (중복조합은 i+1이 아니라 i를 대입하면 됨.)
- ```java
  public class AlgorithmStudy {
    public static void combination(int[] arr, boolean[] visited, int start, int depth, int r){
        if(depth == r){
            for(int i=0; i<arr.length; i++){
                if(visited[i]) System.out.print(arr[i]);
            }
            System.out.println();
            return;
        }

        for(int i=start; i<arr.length; i++){
              out[depth] = arr[i];  // list나 arr로 뽑힌 원소 저장 가능 (꼭 visited아니여도 됨.)
              combination(arr, visited, i+1, depth+1, r);
        }
    }

    public static void main(String[] args){
        int[] arr = {1, 2, 3};
        int r = 2;
        combination(arr, new boolean[arr.length], 0, 0, r);
    }
  }
- ```


### [광물 캐기]
- 원래 풀이: 곡괭이 0, 1, 2로 풀어헤치고 arr만듦. 0011122 이런식으로. 그리고 조합 진행함.(중복 감수)
- 시간 초과 문제
  - map 이용 중복 제거 -> 효과는 있었지만, 이걸로 충분 x
  - 조합을 뽑아두고 진행하는 게 아니라 뽑으면서 진행. -> 이걸로도 충분x 
    - 🔥 피드백: 다 조합하고 나서 다 뽑고 나서 요리하는 게 아니라, 가능하다면 조합하면서 요리!!
  - 근본적인 중복을 줄였어야 해. -> 백트랙킹하는 방식 바꿈.
    - 기존 풀이와는 다르게 중복되지 않음. 새로운 풀이에서는 똑같은 곡괭이를 반복해서 쓰지 않으니까.
- 🔥🔥🔥 코드 한 줄 한 줄 생각 담아서..


### [메뉴 리뉴얼]
- 배열, 리스트 연결성 주의
  - 특히, 깔끔하게 복원해야 하는 백트랙킹에서는 각별한 주의가 필요하다!
  - return 전에 sort했으면 이 또한 다시 복원해야 한다.
  - for문 재귀 전에 한 행동 뿐만 아니라 if 절에서 한 행동까지도 복원해야 한다!!!
- 큰 구조 짜는 건 좋은데 처음부터 무리하게 크게 만들지마!! -> 나중에 테스트, 검증할 때 힘들다.
  - 작은 것부터 확실하게 만들자. 
  - 기능을 구현했으면, 세밀하고 면밀하게 검증하자.
    - 세밀한 검증을 확실한 디버깅을, 널널한 검증을 불안한 디버깅을 낳는다.
- 조합에서 idx는 int i = idx에서만 나오고, for 문 안에서는 일반적으로 안나온다!!!
  - 이거 실수 주의해!! for 문 안에서는 i위주로 간다. 
  - 조합, 순열 손에 익히자.
- Map 순회, 레퍼런스
  - Map 순회하고 싶은데 기억 안 나서 레퍼런스 뒤져봤는데 결국 해결 못함.
  - 레퍼런스 생활코딩 강의
- Map 순회 방법
  - entrySet()
    - ```java
        Map<String, String> map = new HashMap<>();
      
        for (Map.Entry<String, String> entry : map.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();
        }

        Set<Map.Entry<String, String>> entrySet = map.entrySet();
    - ```
  - keySet()
    - ```java
      Map<String, String> map = new HashMap<>();
      
      for (String key : map.keySet()) {
          map.get(key);
      }
    - ```
- 반복문 중첩해있을 때, 특정 로직이 어디 안에 있어야 하는지 민감하게 반응하자.
- String[] to String
- orders 미리 정렬해두었다면 중간에 백트랙킹에서 정렬할 필요 없었음. 조합 순차적으로 뽑기에.

### 2/22 목 시험 종합 피드백
- sql 풀고 알고리즘 풀다가 막히니까 sql 검토하러 간 점 good. 리프레시 적극 이용
- 시험 전, 카페인, 샤워, 뇌활성화 설계하기
- 시험 중, 전체 플로우, 시간관리 설계하기