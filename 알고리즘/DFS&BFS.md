## DFS/BFS
### 사전 개념
- 탐색: 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
- 대표적인 탐색 알고리즘: DFS, BFS
- 스택: 박스 쌓기
- 큐: 대기 줄
- 재귀 함수: 내부적으로 스택 자료구조와 동일함. 따라서, 스택을 활용해야 하는 상당수 알고리즘은 재귀 함수를 이용해서 간편하게 구현할 수 있음.
- 그래프 개념
  - 그래프 탐색: 하나의 노드를 시작으로 다수의 노드를 방문하는 것
  - 노드(Node): 비유 - 도시 (정점이라고도 함.)
  - 간선(Edge): 비유 - 도로
  - 두 노드는 인접하다 = 두 노드가 간선으로 연결되어 있다
- 그래프 표현 방식
  - 인접 행렬
    - 의미: x, y 두 노드간의 연결을 graph[x][y]로 표현
    - 시간 복잡도: O(N^2) (노드 N^2만큼 필요)
    - 두 노드의 연결 체크: graph[x][y]의 값으로 직관적으로 확인 가능
    - 인접 노드 체크: N^2만큼 반복문을 돌아 확인 가능
    - 사용 tip: 간선이 많을 떄 사용
  - 인접 리스트
    - 의미: x, y 두 노드간의 연결을 graph<x>내에 y원소로 표현
    - 시간 복잡도: O(N) (간선의 개수)
    - 두 노드의 연결 체크: graph<x>의 원소에서 y가 나올 때까지 탐색
    - 인접 노드 체크: 각 리스트에 담겨 있는 원소 확인
    - 사용 tip: 간선이 적을 때 사용

### DFS(Depth-First-Search) 깊이 우선 탐색
- 의미: 그래프에서 깊은 부부을 우선적으로 탐색하는 알고리즘.
- 기초: 스택 자료 구조에 기초함.

### BFS(Breadth-First-Search) 너비 우선 탐색
- 의미: 가까운 노드부터 탐색하는 알고리즘.
- 기초: 큐 자료 구조에 기초함.
- 속도: 보통 DFS보다 BFS 구현이 좀 더 빠르게 작동함.

---

## BFS 문제 풀이 피드백
### [특정 거리의 도시 찾기](백준/Silver/18352. 특정 거리의 도시 찾기)
- 모든 경로 길이가 똑같고 최단 경로를 구하라하면 BFS유리
  - 이 때, visited[]를 distance[]로! 방문은 -1 초기화로 대체할 수 있음.

### [단어 변환](프로그래머스/3/43163. 단어 변환)
- 최단거리는 dfs보다는 bfs가 더 효율적.
- 최단거리는 거리 d 배열을 따로 선언하거나, Node 클래스에 cost를 통해 저장할 수 있음.

### [치킨 배달](백준/Gold/18405. 경쟁적 전염)
- Node 클래스에서 필드 변수들 static이라 해버림.. (그래서 마지막에 저장된 걸로 값이 다 바뀌어버림. 다 3으로) static 쓰는 거 조심하자!! 특히 변수는 뭉개지니까 조심!!
- 우선순위 큐 그저 Comparable 상속받고 compareTo 오버라이딩 해두면 됨.
- bfs와 재귀를 융합한 재밌는 문제 or 시간을 node 필드 변수로 선언해서 풀 수도 있음. 

### [게임 맵 최단거리](프로그래머스/2/1844. 게임 맵 최단거리)
- bfs에서 최단 거리를 구할 때 거리 저장 방법
  - 거리 저장만을 위한 d 배열 따로 선언
  - Node 클래스에 cost 변수 선언
  - graph(인접 행렬 map)에 직접 저장
- 클래스 안에 내부 클래스를 선언할 때 static으로 선언하면 장점
  - 독립성 확보: 외부 클래스의 인스턴스에 상관없이 내부 클래스의 인스턴스 생성할 수 있음.
  - 외부 클래스와의 결합 감소: static으로 선언한 내부 클래스는 외부 클래스의 멤버나 메서드에 직접적으로 접근할 수 없음.




## DFS 문제 풀이 피드백
### [연구소] (백준/Gold/14502. 연구소)
- 인접 행렬에서 이동해야 하는 경우는 dx, dy로 처리하자!!!
- 행열 x, y 그대로 행, 열로 활용하자!!
- 인접 행렬에서 3가지를 랜덤으로 뽑고 싶다면?
```java
public static void dfs(int count) {
        if (count == 3) {
            // 처리하고 싶은 코드
            return;
        }

        // 반복문을 통해서!! 모든 원소를 돌 수 있도록 처리.
        // 재귀(stack)를 통해서 모든 경우의 수 처리.
        // (0,0), (0,1), (0,2) -> (0,0), (0,1), (0,3) -> ...
        // (0,0), (0,1), (1,0) -> ...
        // (0,0), (0,2), (0,3) -> ...
        /// (0, 1), (0, 2), (0, 3) -> ...
        for (int i = 0; i < n; i++) { 
            for (int j = 0; j < m; j++) { 
                if (graph[i][j] == 0) {
                    graph[i][j] = 1;
                    count += 1;
                    dfs(count);

                    graph[i][j] = 0;
                    count -= 1;
                }
            }
        }
    }
```

### [연산자 끼워넣기](백준/Silver/14888. 연산자 끼워넣기)
- 순열 알고리즘 이해해보자
```java
public static void permute(ArrayList<Integer> list, int start) {
        if (start == list.size() - 1) {
            System.out.println(list);
            return;
        }

        for (int i = start; i < list.size(); i++) {
            Collections.swap(list, start, i);
            permute(list, start + 1);
            Collections.swap(list, start, i); // backtrack
        }
    }
```

### [타겟 넘버](프로그래머스/2/43165. 타겟 넘버)
- **매개변수와 같은 이름으로 필드에 선언해두면 안 돼!!**
- 규칙 찾아서 이를 통해 풀려고 하니 오히려 더 복잡해짐. depth가 안 정해져 있어서.
- 규칙 찾는 게 능사는 아님. 다양한 풀이를 고려해야 함.(출제의도파악)

### [깊이 우선 탐색 1](<../백준/Silver/24479. 알고리즘 수업 － 깊이 우선 탐색 1>)
- 단순한 순간이어도 급하게는 하지 말자!! 괜히 실수해두면 디버깅하는 데 오래 걸린다!!!
- 무방향(양방향) 그래프라면 인접 리스트에 삽입할 때 두 번 삽입해야 한다!
- 문제 잘 읽자! 항상 N개의 줄의 입력값이 주어지는 게 아니다! (그래도 디버깅할 때 잘 캐치함.)


### [네트워크](프로그래머스/3/43162. 네트워크)
- visited에서 모든 인접 행렬을 나타낼 필요가 없어. 노드의 개수만큼만 방문 배열 필요해.