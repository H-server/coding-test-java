## DFS/BFS
### 사전 개념
- 탐색: 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
- 대표적인 탐색 알고리즘: DFS, BFS
- 스택: 박스 쌓기
- 큐: 대기 줄
- 재귀 함수: 내부적으로 스택 자료구조와 동일함. 따라서, 스택을 활용해야 하는 상당수 알고리즘은 재귀 함수를 이용해서 간편하게 구현할 수 있음.
- 그래프 개념
  - 그래프 탐색: 하나의 노드를 시작으로 다수의 노드를 방문하는 것
  - 노드(Node): 비유 - 도시 (정점이라고도 함.)
  - 간선(Edge): 비유 - 도로
  - 두 노드는 인접하다 = 두 노드가 간선으로 연결되어 있다
- 그래프 표현 방식
  - 인접 행렬
    - 의미: x, y 두 노드간의 연결을 graph[x][y]로 표현
    - 시간 복잡도: O(N^2) (노드 N^2만큼 필요)
    - 두 노드의 연결 체크: graph[x][y]의 값으로 직관적으로 확인 가능
    - 인접 노드 체크: N^2만큼 반복문을 돌아 확인 가능
    - 사용 tip: 간선이 많을 때 사용
  - 인접 리스트
    - 의미: x, y 두 노드간의 연결을 graph<x>내에 y원소로 표현
    - 시간 복잡도: O(N) (간선의 개수)
    - 두 노드의 연결 체크: graph<x>의 원소에서 y가 나올 때까지 탐색
    - 인접 노드 체크: 각 리스트에 담겨 있는 원소 확인
    - 사용 tip: 간선이 적을 때 사용

### DFS(Depth-First-Search) 깊이 우선 탐색
- 의미: 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘.
- 기초: 스택 자료 구조에 기초함.

### BFS(Breadth-First-Search) 너비 우선 탐색
- 의미: 가까운 노드부터 탐색하는 알고리즘.
- 기초: 큐 자료 구조에 기초함.
- 속도: 보통 DFS보다 BFS 구현이 좀 더 빠르게 작동함.

---

## BFS 문제 풀이 피드백
### [특정 거리의 도시 찾기](백준/Silver/18352. 특정 거리의 도시 찾기)
- 모든 경로 길이가 똑같고 최단 경로를 구하라하면 BFS유리
  - 이 때, visited[]를 distance[]로! 방문은 -1 초기화로 대체할 수 있음.

### [단어 변환](프로그래머스/3/43163. 단어 변환) X 3
- 첫 번째 풀이: 갈 수 있는 경로를 인접 리스트로 전처리 해두고 bfs 돌림.
  - 최단거리는 dfs보다는 bfs가 더 효율적.
  - 최단거리는 거리 d 배열을 따로 선언하거나, Node 클래스에 cost를 통해 저장할 수 있음.

- 두 번째 풀이: 설계 덜 하고 bfs 하다가, dfs로 바꿔서 품.
  - private static List<Integer> answer; 이렇게 두지마!! 선언해라!!
  - list.remove(words[i]); // 스트링 객체 String 이처럼 삭제 가능!
  - bfs로 하다가 최솟값 보장이 안 돼서 dfs로 넘어감. 또한, 하나의 경로를 여러 번 방문할 수도 있는데 이를 무르기가 어려움. 그렇다고 방문 배열 없으면 순환 참조할까봐 dfs로 갈아탐. (그러나, 한 번 방문 처리한 곳을 다시 방문하지 않음.) (다시 방문하면 오히려 손해임. (다익스트라를 떠올려라! 지금 당장 방문한 곳은 최단 거리 보장.))
  - 최단거리다고 해서 무조건 bfs가 유리한 건 x 해당 문제에서는 dfs가 더 빠름.

- 세 번째 풀이: 전처리 안 하고 bfs로 풀어보기!!
  - 🔥 bfs로 풀기 위해서는 해당 노드에 대한 비용을 저장하고 있어야 함. 따라서 String과 int를 동시에 담을 수 있는 Class 선언했음.
  - ```java
      private static class Node {
        String word;
        int cost;
        
        Node(String word, int cost) {
            this.word = word;
            this.cost = cost;
        }
      }
  - ```
  - 🔥 혹은 최단 거리 저장 배열을 따로 선언할 수 있음!!!


### [치킨 배달](백준/Gold/18405. 경쟁적 전염)
- 🔥 Node 클래스에서 필드 변수들 static이라 해버림.. (그래서 마지막에 저장된 걸로 값이 다 바뀌어버림. 다 3으로) static 쓰는 거 조심하자!! 특히 변수는 뭉개지니까 조심!!
- 우선순위 큐 그저 Comparable 상속받고 compareTo 오버라이딩 해두면 됨.
- bfs와 재귀를 융합한 재밌는 문제 or 시간을 node 필드 변수로 선언해서 풀 수도 있음. 

### [게임 맵 최단거리](프로그래머스/2/1844. 게임 맵 최단거리) x 2 (bfs 최단거리 복습하고 싶다면 ㄱㄱ)
- 🔥 bfs에서 최단 거리를 구할 때 거리 저장 방법
  - graph(인접 행렬 map)에 직접 저장
  - 거리 저장만을 위한 d 배열 따로 선언
  - Node 클래스에 cost 변수 선언
- 🔥 클래스 안에 내부 클래스를 선언할 때 static으로 선언하면 장점
  - 독립성 확보: 외부 클래스의 인스턴스에 상관없이 내부 클래스의 인스턴스 생성할 수 있음.
  - 외부 클래스와의 결합 감소: static으로 선언한 내부 클래스는 외부 클래스의 멤버나 메서드에 직접적으로 접근할 수 없음.


### [전력망을 둘로 나누기](../프로그래머스/프로그래머스/2/86971. 전력망을 둘로 나누기) x2 (dfs 숙련도 높이고 싶다면 고고)
- 🔥 인접 행렬 혹은 인접 리스트에 정보 저장할 때, **양방향 그래프라면** 양쪽에 추가해야 된다!! 하나만 추가하지마!!
  - 그리고 간선의 삭제, 복구도 양쪽에 해야한다!
- 풀이 아이디어 있다고 해서 바로 들어가지마!! 아이디어 명확하더라도 구체화해라!
- 🔥 list에서 특정 요소 삭제하고 싶을 때, index가 아니라 객체도 넘겨줄 수 있다. 이를 통해 특정 요소 바로 삭제 가능.
  - list.remove(Integer.valueOf(1));
    - 1이라는 첫번째 요소를 삭제함.
    - Integer 클래스의 valueOf() 메서드는 주어진 정수 값에 대한 Integer 객체를 반환함.
  - list에서 특정 요소 전체 삭제
    ```java
    // value가 1인 element 삭제
    while (list.remove(Integer.valueOf(1))) {
    };

    // value가 1, 2인 element 모두 삭제
    list.removeAll(Arrays.asList(Integer.valueOf(1), Integer.valueOf(2)));
    ```
  - String[] fruitsArray = {"apple", "banana", "kiwi", "mango"};
    - fruits.remove("apple");
- 인접행렬, dfs로도 가능함. 어떤 것 써도 큰 상관없음.


- 아 그래프 간선 삭제하는 작업 빠뜨림. 메서드까지는 생각해뒀는데. 
  - 🔥 들여쓰기 설계할 때 생각나는 거 있으면 우선 모조리 적어둬야 함.
    - 🔥 정갈하게 적어두는 건 마지막에 고치면 됨.
- 🔥 많이 쉬워보이거나 설계에서 길이 뚜렷하게 보여도 차분해야 한다. 꾹꾹 눌러서!!
- dfs, bfs 복습하자
- ```java
  // 인접 리스트 기준
  public static void dfs(int x) {
    visited[x] = true;

    for (int i = 0; i < graph.get(i).size(); i++) {
      int y = graph.get(x).get(i);
      if (!visited[y]) {
        dfs(y);
      }
    }
  }

    // BFS 함수 정의
  public static void bfs(int start) {
      Queue<Integer> q = new LinkedList<>();
      q.offer(start);
      // 현재 노드를 방문 처리
      visited[start] = true;
      // 큐가 빌 때까지 반복
      while(!q.isEmpty()) {
          // 큐에서 하나의 원소를 뽑아 출력
          int x = q.poll();
          System.out.print(x + " ");
          // 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
          for(int i = 0; i < graph.get(x).size(); i++) {
              int y = graph.get(x).get(i);
              if(!visited[y]) {
                  q.offer(y);
                  visited[y] = true;
              }
          }
      }
  }
- ```



## DFS 문제 풀이 피드백
### [연구소] (백준/Gold/14502. 연구소)
- 인접 행렬에서 이동해야 하는 경우는 dx, dy로 처리하자!!!
- 행열 x, y 그대로 행, 열로 활용하자!!
- 인접 행렬에서 3가지를 랜덤으로 뽑고 싶다면?
```java
public static void dfs(int count) {
        if (count == 3) {
            // 처리하고 싶은 코드
            return;
        }

        // 반복문을 통해서!! 모든 원소를 돌 수 있도록 처리.
        // 재귀(stack)를 통해서 모든 경우의 수 처리.
        // (0,0), (0,1), (0,2) -> (0,0), (0,1), (0,3) -> ...
        // (0,0), (0,1), (1,0) -> ...
        // (0,0), (0,2), (0,3) -> ...
        /// (0, 1), (0, 2), (0, 3) -> ...
        for (int i = 0; i < n; i++) { 
            for (int j = 0; j < m; j++) { 
                if (graph[i][j] == 0) {
                    graph[i][j] = 1;
                    count += 1;
                    dfs(count);

                    graph[i][j] = 0;
                    count -= 1;
                }
            }
        }
    }
```

### [연산자 끼워넣기](백준/Silver/14888. 연산자 끼워넣기) x 2 (또 풀어봐도 좋다!)
- 순열 알고리즘 이해해보자
- ```java
  public static void perm(int[] arr, int[] output, boolean[] visited, int depth, int n, int r) {
      if (depth == r) {
          print(output, r);
          return;
      }
   
      for (int i=0; i<n; i++) {
          if (!visited[i]) {
              visited[i] = true;
              output[depth] = arr[i];
              perm(arr, output, visited, depth + 1, n, r);       
              output[depth] = 0; // 이 줄은 없어도 됨
              visited[i] = false;;
          }
      }
  }
  ```
- 원래 풀이는 순열 경우의 수 세팅해둔 뒤, 연산 처리함.
  - 경우의 수 백트랙킹으로 처리하면서 연산할 수도 있음.
  - op를 직접 순열처리하지 않아도 됨. 각각의 개수만 있다면.
  - 최대 최소도 즉각 처리할 수 있음. list에 저장해두는 게 아니라. Math.min
- 백트랙킹을 이와 같이도 여러개 메서드 둘 수 있음. 사실 for문을 풀어헤친 것임.

### [타겟 넘버](프로그래머스/2/43165. 타겟 넘버)
- **매개변수와 같은 이름으로 필드에 선언해두면 안 돼!!**
- 규칙 찾아서 이를 통해 풀려고 하니 오히려 더 복잡해짐. depth가 안 정해져 있어서.
- 🔥 규칙 찾는 게 능사는 아님. 다양한 풀이를 고려해야 함.(출제의도파악)

### [깊이 우선 탐색 1](<../백준/Silver/24479. 알고리즘 수업 － 깊이 우선 탐색 1>)
- 🔥 단순한 순간이어도 급하게는 하지 말자!! 괜히 실수해두면 디버깅하는 데 오래 걸린다!!!
- 무방향(양방향) 그래프라면 인접 리스트에 삽입할 때 두 번 삽입해야 한다!
- 문제 잘 읽자! 항상 N개의 줄의 입력값이 주어지는 게 아니다! (그래도 디버깅할 때 잘 캐치함.)


### [네트워크](프로그래머스/3/43162. 네트워크) x 2 (dfs/bfs 감 떨어졌으면 다시 풀어봐. 그게 아니라면 넘겨.)
- visited에서 모든 인접 행렬을 나타낼 필요가 없어. 노드의 개수만큼만 방문 배열 필요해.
- (약)🔥 bfs에서 방문 확인은 보통 while 문 안에서 한다! (start쪽에서 하는 게 아니라)
- (약)🔥 while 문 안에서 visited 확인해라!
- 🔥 🔥 idea 거칠게 적은뒤, 주석으로 depth 들여쓰기 하면서 코드 설계한 점 gooooooood

### [감시 피하기](백준/Gold/18428. 감시 피하기)
- 이와 비슷한 문제 어떻게 풀었더라? 기둥 설치하는 거!
- 추가적인, 부수적인 메서드 선언 두려워하지 말자

### [인구 이동](백준/Gold/16234. 인구 이동) x2 (다시 풀어보기)
- 첫 번째 풀이 - dfs
  - BFS로도 풀 수 있음. (그러나 dfs가 더 편한 듯)
  - 하나의 시행에서 dfs를 여러 번 했어야 하는 문제. 그리고 그 하나의 시행을 특정 조건을 충족할 때까지 반복했어야 하는 문제. dfs에 반복을 두 번 감싸야 함.
  - 이상, 이하 조건 잘 챙기자!! 등호 붙여야 해.

- 두 번째 풀이 - bfs
  - 하나의 그래프에서 온전히 bfs를 시행하기 위해 이중 반복문을 돔. 그리고 그 하나의 시행을 여러번하기 위해 while로 감쌈.
  - 🔥 하나의 시행이 무엇인지 정확히 파악해야 한다!!!
    - 하나의 시행에서 꼭 연합군이 하나인 건 아니다! 여러 개 있을 수 있다! (문제 제대로 읽지 않고, 설계도 꼼꼼히 하지 않은 탓.)


### [아이템 줍기](프로그래머스/3/87694. 아이템 줍기)
- 처음에 풀이 아이디어의 온전한 검증을 놓쳤지만, 마지막 아이디어 기지를 발휘해서 60분 안에 품. 
  - 놓쳤던 부분: 내 풀이로 간다면 직사각형을 통과해서 가는 것도 허용됨. 정점만 표시해서 될 게 아니라 간선도 신경썼어야 함. 
  - 고친 부분: 간선을 따로 저장하는 게 아니라, 애초에 통과해서 갈 수가 없도록 모든 좌표를 *2 처리함. 
  - 🔥 피드백: 내가 생각한 아이디어를 컴퓨터도 알아들을 수 있는지 좀 더 검증해야 함. 검증에서 꼼꼼히 해야 나중에 디버깅 시간을 단축시킬 수 있음. 
  - 🔥 피드백: **아이디어를 떠올렸다면, 작게나마 직접 시행해보고, 예외 케이스도 생각해보자. (설계 차분히 한 건 좋았는데, 검증 과정이 부재했다.)**
- 방문처리 -1이 아니라 0이라 해도 됐었음.
  - 인접 행렬에서 음수 들어간 숫자 넣으면 출력했을 때, 가독성이 매우 떨어짐. 음수 붙이는 건 왠만하면 지양하자.
- 전처리 아이디어를 떠올리는 데 까다로웠던 문제. bfs 처리는 평범했다. 
- 이미지 예시에서는 (x, y) 그래프로 나왔지만, 자연스레 인접행렬로 바꿔서 푼 점 good. 
  - 그래프에서 시계방향으로 90도 회전한 것과 같음. (y=x 대칭이동, x축 대칭 동)


### [소트 게임]
- 실전에서는 풀이 아이디어가 명확히 나오지 않는다면, 넘기자. 괜히 밍기적거리면 안 돼!!
  - 연습 때도 풀이 아이디어 명확하지 않다면 북마크 해두고 넘어가자!! 이제 실전을 어느 정도 고려해야 해.
  - 🔥 실전에서는 내가 정말 풀 수 있는 문제와 그렇지 않은 문제를 filtering하는 데에도 시간을 계획해야 할 듯. 

### [여행경로]()
- 🔥 문제를 정말 꾹꾹 눌러서 꼼꼼히 읽어야 하는 이유... 
  - 여기서는 항공권을 모두 이용하는 게 관건!! 특정 여행지에 따라 모든 항공권을 소비하지 못할 수 있음. 따라서, 알파벳 먼저인 걸 고르는 게 항상 능사가 아님. 백트랙킹을 시도해야 함.
  - 🔥 문제가 짧을 수록 general할수록 특정 조건을 놓치면 크리티컬하게 작용함. 짧거나 길거나 꼼꼼히 읽어야 해!
- 🔥 무언가 사용했는지 존재하는지 확인하려면 삽입&삭제보다는 방문 배열을 적극적으로 활용하자!! 경우에 따라 set도 활용 가능. 
- 🔥 Arrays.sort(tickets, (a, b) -> b[1].compareTo(a[1]));
  - 메서드 숙지하자! String 비교하는 것.


### [퍼즐 조각 채우기](프로그래머스/3/84021. 퍼즐 조각 채우기)
- 🔥 문제 한 번 훑고 시작하기! 바로 정독하는 것보다는!!
- 호흡이 역대급으로 길었던 문제. 차분히 메서드별로 잘 구현하고, 디버깅 중간중간 착실히 했다.
- 다음에 리팩토링 ㄱㄱ

### [불량 사용자](프로그래머스/3/64064. 불량 사용자)
- 시간 초과 나면 우선 거시적으로 바라봐야 해. 이중 반복문이 있다면 이것부터 봐야지!
- 🔥 Set<Set<String>> 이를 통해 set을 다시 한 번 더 중복 검사할 수 있음.
- 🔥 set 선언할 때 new Hashset<>()이 아니라 new HashSet<>()!!
- dfs 넘겨줄 때 new HashSet<>()으로 감싸서 인자 보내줘야 하는 이유 알아보기 (아마 얕은 복사에 있지 않을까?)


### [거리두기 확인하기](프로그래머스/2/81302. 거리두기 확인하기)
- 실패시 어떤 거 때문에 틀렸는지 경우의 수 대략적으로 나눈 점 good.
  - 원인은 제자리로 돌아오는 중복제거였음. 그 중에서도 visited 방문처리 순서!! (유효한 좌표일 때만 방문처리 해야해!)
- tap 설계에서 꼭 하나의 루프로 표현하려고 하지말자. 복잡하면 나누자. 
- 리팩토링에서 일단 방법이 있다면 비효율적인 것 같아도 적극적으로 시도해보기!! 익숙한거면 good
- charAt은 읽기만 가능함.
  - 문자열 특정 위치 문자 바꾸려면? -> sb 이용! setCharAt!!!! 
  - ```java
      // StringBuilder를 사용하여 문자열을 수정할 수 있도록 변환
      StringBuilder sb = new StringBuilder(myString);
      
      // 인덱스 7의 문자를 'X'로 변경
      sb.setCharAt(7, 'X');
      
      // 변경된 문자열을 출력
      System.out.println(sb.toString()); 
  - ```
  - Arrays.toString()을 이용하는 방법도 있다!! 프린트문에서만 쓰이는 게 아니야!
  - ```java
      String[] c = s.split("");
      s[7] = 'X';
      s = Arrays.toString(c);
  - ```

### [단지번호붙이기](../백준/Silver I/2667. 단지번호붙이기)
- 일반적인 bfs 방문처리는 두 개의 줄에 있음!! start에서 한 번, offer할 때 한 번
- chat를 int에 바로 저정하면 아스키코드로 된다!! 해결: Integer.parseInt(String.valueOf(c.charAt(j)))
- 내림차순 정렬 정리하기 (학습)
  - 리스트: Collections.sort(words, Collections.reverseOrder()); // String이든 Integer이든 상관x
  - 배열: Integer[] 이런건 위처럼 하면 되지만, 원시형 배열은 내장 메서드가 없음. 
    - 대표적 방법: arr -> list


### [아기 상어](../백준/Gold/16236. 아기 상어)
- visited 순서 중요하다..! 민감하게 살펴보자.
  - 백트랙킹(dfs)에서는 visited 복원해야 한다.
- 🔥 dfs 시간 초과 걸림. 해당 문제가 dfs 풀이가 없는 이유가 있었음.
  - 🔥 🔥 최단 거리 찾을 때는 bfs!!! 잊지말자. 
  - Q에 삽입할 때 class가 아니라 int[]와 같은 배열로 해도 되니까 bfs 부담없이 시도하자.
- 은근 신경 쓸 게 많은 문제였음. 
  - 이럴 때는 완벽히 설계를 하는 것보다는 어느 정도 됐으면 하면서 잠깐씩 다시 메타적으로 설계하는 게 좋은 듯.
- list에서 new ArrayList<>();선언하는 거 잊지말자!!
- 🔥 🔥 이런 빡구현 문제는 메서드 분리를 적극적으로 진행하자. 요새 분리를 안 하긴 한 듯.
  - 각 메서드 별로 잘 작동하는지 확인하고 넘어가기.
  - 기능 세분화해서 하나하나 꼼꼼하게 완성도 있게 작성하자!!


### [가장 먼 노드](../프로그래머스/3/49189. 가장 먼 노드)
- 🔥 그래프 종류에 따른 최단 거리 접근
  - 인접 행렬(지도): bfs, dfs 둘 다 가능 (예시 문제: 게임맵 최단 거리)
    - dfs로 풀기 위해서 visited 추가해서 풀 수 있음.
  - 인접 행렬(간선 정보): bfs만 가능 
  - 인접 리스트(연결 정보): bfs만 가능 (예시 문제: 가장 먼 노드)
    - dfs로 푼다면, 최단 거리 보장하지 못함. (별도의 처리가 필요함.)
- 🔥 '최단 경로'로 이동했을 때!!!!!! '거리' 관련은!!!!!!! '가깝고' '멀고' 관련은!!! -> BFS!!!!
- 🔥 들여쓰기 설계 - 초반 설계에서 껍질만 짠다고 해서.. 대충하지마. 그래도 최대한 해야해. 인지 부하가 오기 전까지는.