### 다이나믹 프로그래밍 (동적 계획법)
- 의미: 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
- 원리: 이미 계산된 결과(작은 문제)를 별도의 메모리 영역에 저장하여 필요할 때 재활용함.
- 조건: 큰 문제를 동일한 작은 문제로 나누어 풀 수 있는가?
  - 최적 부분 구조: 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결
  - 중복되는 부분 문제: 동일한 작은 문제를 반복적으로 해결
- 방식
  - 탑다운(하향식)
    - 메모이제이션
      - 의미: 한 번 계산한 결과를 메모리 공간에 메모하는 기법
      - 다이나믹 프로그래밍을 구현하는 방법 중의 하나
      - 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 함.
  - 보텀업(상향식) !!
    - 다이나믹 프로그래밍의 전형적인 형태
    - DP 테이블: 결과 저장용 리스트
- 문제 접근 방법
  - 가장 먼저 그리기, 구현, 완전 탐색 등으로 아이디어 생각해보기
    - 다른 알고리즘이 떠오르지 않는다면 다이나믹 프로그래밍 고려
  - 우선 재귀함수로 풀이 시도(탑다운). 동일한 작은 문제가 발견되면 리팩토링.

### LIS(Longest Increasing Subsequence) 최장 증가 부분 수열
- 의미: 특정 수열에서 오름차순으로 정렬된 가장 긴 부분 수열을 찾는 알고리즘
- 풀이 종류
  - dp
  - 이진탐색
- 원리: 각 원소의 지위, 랭크를 매기는 작업을 선행함. 
  - 해당 원소에서 그 다음으로 올 수 있는 원소들을 dp에서 +1로 표시하는 것.
- 결과: dp 배열에서 가장 큰 값이 최장 증가 부분 수열의 길이임.
- 소스코드
```java

//dp 배열 1로 초기화

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (list.get(j) < list.get(i)) { // dp자리 아니라 수열 자리다!! 조심
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
```



## 다이나믹 프로그래밍 문제 풀이 피드백
### [정수 삼각형](백준/Silver/1932. 정수 삼각형)
- st.countTokens(); <- 이거 쓰는 거 조심하자!
  - 왜냐하면 nextToken할 때 마다 개수 줄어드니까 예상치 못한 동작 일어날 수 있음.
  - 특히, for 반복문에서 종료 조건, 부등호 


### [퇴사](백준/Silver/14501. 퇴사)
- 백트랙킹에서 idx 복원하는 거 직접적으로 손대지 말자. 
  - 넘어간 뿌리는 그 자리에서 return 하고 끝내야 함. 하지만 직접 건들면 무한루프에 빠질 수 있음. 왜냐하면 return한 후 다시 --해서 for문에서 똑같은 행동 반복하기 때문.
- 백트랙킹을 안 써도 되는 문제였음. 
  - 백트랙킹이 필요한 이유가 중간에서 출발했을 때 더 큰 값이 나올까봐였음. 
  - 그러나 굳이 안 돌아가도 됨. i++ 하나씩 가면서 체크하면 그 이전까지 최댓값이 보장되기 때문. 
  - 백트랙킹 이전에 온전한 다이나믹으로 풀 수 있는지 체크.
  - 근데 백트랙킹을 생각했던 이유가 겹치면 안 되기 때문이었음. 겹칠 경우가 없음. 
- 예제로 주어진 시행횟수가 크다면 줄여서 시뮬레이션 해보기