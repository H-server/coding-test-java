## 재귀
### [쿼드압축](프로그래머스/Lv.2/68936. 쿼드압축 후 개수 세기)
- 재귀 3요소: 상태, 종료 조건, 점화식

### [하노이의 탑](프로그래머스/Lv.2/12946. 하노이의 탑)
- 풀이에 전혀 감이 안 올 때: 우선 시행해보기 -> 관찰 -> 규칙성 발견
- 재귀는 재귀로 푸는 게 코드 간결해짐.
- 배열 복사
  - 얕은 복사: 객체의 주소만을 복사
  - 깊은 복사: 객체의 실제값까지 복사하여 새로운 객체 생성 (for문 추천)
- 2차원 리스트 to 2차원 배열
- System.out.print 반복문 안에서 사용하다면 제출할 때 '출력 크기 초과' 걸릴 수 있음!
  - 최종 제출 전엔 프린트문 빼자!
- 솔루션 클래스 내 메서드 선언은 private로!
- 메서드 내 실행 중단하고 싶을 때: return;
- list to array
```java
list.toArray(); // Object[]로 반환
String[] array = list.toArray();
String[] array = list.toArray(new String[0]); // 타입 명시

List<int[]> process = new ArrayList<>();
return process.toArray(new int[0][]);
```
- list의 변경 (매개변수 통한) <-> 일반 변수 알아보기!!

### [택배 배달과 수거하기]  (아직못품)
- 처음 설계 부족했음. 입출력 예만 믿고 따라감. 다른 예외적인 경우 생각하지 않고 설계해버림.
  - 테스크 케이스 이외에도 능동적으로 생각하고 설계하자!!
- 처음부터 너무 무리하게 쫀쫀하게 짜려고 하지 말자. 그러다가 디버깅하는 데 시간 오히려 더 걸린다.
  - 더럽더라도 구현하는 게 중요하다. 그렇다고 급해지진 말고. 특히 디버깅에서 급해지면 답없다.
- 런타임 에러
  - 인덱스 오류(Index Out of Bounds): 배열 인덱스를 잘못 참조하는 경우가 있습니다. 코드를 주의 깊게 살펴보세요. 특히 반복문에서 인덱스를 처리할 때, 인덱스의 범위를 벗어나지 않도록 주의해야 합니다. 예를 들어, for 루프를 통해 배열을 역순으로 탐색할 때, 인덱스가 0에서 시작하는지, 1에서 시작하는지 등을 확인해야 합니다.
  - 무한 루프(Infinite Loop): 잘못된 종료 조건이나 재귀 호출 등으로 인해 무한 루프에 빠지는 경우가 있습니다. 함수나 반복문의 종료 조건을 정확하게 설정하고, 재귀 호출 시에는 베이스 케이스를 반드시 처리해야 합니다.
  - 메모리 부족(Memory Overflow): 재귀 호출이 너무 깊어지거나, 대규모 배열을 생성하거나 할 때 메모리 부족이 발생할 수 있습니다. 이 경우에는 알고리즘을 최적화하거나, 재귀 호출을 반복문으로 변환하는 등의 방법으로 문제를 해결할 수 있습니다.
  - 자료형 오류(Data Type Error): 변수의 자료형이 잘못 지정되어 있는 경우가 있습니다. 예를 들어, 정수형 변수를 오버플로우할 수 있는 범위를 넘어서 사용하는 경우 등이 있습니다.
  - 출력 형식 오류(Output Format Error): 출력 형식이나 반환 값의 형식이 잘못된 경우가 있습니다. 문제의 요구 사항을 정확히 이해하고, 그에 맞춰 출력 형식을 지정해야 합니다.
- 상당히 dp스러운 문제
