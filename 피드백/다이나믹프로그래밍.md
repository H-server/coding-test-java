### 다이나믹 프로그래밍 (동적 계획법)
- 의미: 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
- 원리: 이미 계산된 결과(작은 문제)를 별도의 메모리 영역에 저장하여 필요할 때 재활용함.
- 조건: 큰 문제를 동일한 작은 문제로 나누어 풀 수 있는가?
  - 최적 부분 구조: 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결
  - 중복되는 부분 문제: 동일한 작은 문제를 반복적으로 해결
- 방식
  - 탑다운(하향식)
    - 메모이제이션
      - 의미: 한 번 계산한 결과를 메모리 공간에 메모하는 기법
      - 다이나믹 프로그래밍을 구현하는 방법 중의 하나
      - 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 함.
  - 보텀업(상향식) !!
    - 다이나믹 프로그래밍의 전형적인 형태
    - DP 테이블: 결과 저장용 리스트
- 문제 접근 방법
  - 가장 먼저 그리기, 구현, 완전 탐색 등으로 아이디어 생각해보기
    - 다른 알고리즘이 떠오르지 않는다면 다이나믹 프로그래밍 고려
  - 우선 재귀함수로 풀이 시도(탑다운). 동일한 작은 문제가 발견되면 리팩토링.

### 🔥 LIS(Longest Increasing Subsequence) 최장 증가 부분 수열
- 의미: 특정 수열에서 **몇 개의 원소를 선택해** 오름차순으로 정렬된 가장 긴 부분 수열을 찾는 알고리즘 
- 풀이 종류
  - dp
  - 이진탐색
- 🔥 원리: 각 원소의 지위, 랭크를 매기는 작업을 **순차적으로** 선행함. 
  - 해당 원소의 index보다 앞에 있는 원소들 중 가장 큰 걸 고름. 
- 🔥 결과: dp 배열에서 가장 큰 값이 최장 증가 부분 수열의 길이임.
- 🔥 소스코드
```java

//dp 배열 1로 초기화

    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (list.get(j) < list.get(i)) { // dp자리 아니라 수열 자리다!! 조심
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
    }
```

## 다이나믹 프로그래밍 문제 풀이 피드백
### [정수 삼각형](../백준/Silver/1932. 정수 삼각형)
- 🔥 st.countTokens(); <- 이거 쓰는 거 조심하자!
  - 왜냐하면 nextToken할 때 마다 개수 줄어드니까 예상치 못한 동작 일어날 수 있음.
  - 특히, for 반복문에서 종료 조건, 부등호 


### 🔥 [퇴사](../백준/Silver/14501. 퇴사) X 2 (해설 보고 품.)
- 백트랙킹에서 idx 복원하는 거 직접적으로 손대지 말자. 
  - 넘어간 뿌리는 그 자리에서 return 하고 끝내야 함. 하지만 직접 건들면 무한루프에 빠질 수 있음. 왜냐하면 return한 후 다시 --해서 for문에서 똑같은 행동 반복하기 때문.
- 백트랙킹을 안 써도 되는 문제였음. 
  - 각 일수에서 하거나 말거나 선택하면 됨. 이에 따라 향후 배열 갱신.
  - 백트랙킹이 필요한 이유가 중간에서 출발했을 때 더 큰 값이 나올까봐였음. 
  - 그러나 굳이 안 돌아가도 됨. i++ 하나씩 가면서 체크하면 그 이전까지 최댓값이 보장되기 때문. 
  - 백트랙킹 이전에 온전한 다이나믹으로 풀 수 있는지 체크.
  - 근데 백트랙킹을 생각했던 이유가 겹치면 안 되기 때문이었음. 겹칠 경우가 없음. 
- 예제로 주어진 시행횟수가 크다면 줄여서 시뮬레이션 해보기

### [등굣길]
- x, y 뒤집었으면 다른 것도 민감하게 반응!!!
- 설계 정말 중요해.. 경우에 따라서는 20분까지 설계하는 것도 염두에 두자.
  - 정형화된 행동이 지속해서 반복된다면 && 시간 복잡도 타이트하다면 -> dp
- 마지막은 갱신 안 되니 리턴 할 때 한번 더 나눠줘야 함...!!
  - '로 나눈 나머지로 출력하세요.' 사소한 조건이라도 생각 담아서 정성껏 작성해라.

### [신나는 함수 실행]
- 차분히 설계하고 들어가자!! 쉬운 문제는 없다!
- 메모이제이션 "메모" 하는 데 초점 두자!

### [01타일]
- 다음에 풀 때 피보나치인 것 제대로 증명해보기
- 프로그래밍에게 맡기는 것도 중요하지만, dp에서는 능동적으로 규칙성 찾는 것 중요하다!
- 15746으로 나누기!! 조건 하나하나 민감하게!!
- 해당 문제를 dp로 풀어야 하는 이유: 제곱 연산이 무한을 넘겨 버림. 2의 5000제곱 해버리니..

### [파도반 수열]
- 항상 숫자 범위 조심하자!!
- 검토할 때 int, long 체크하자!

### [연속합]
- dp는 종이에 많이 써보는 연습하자! + 순차적 사고!!

### [쉬운 계단 수]
- int와 long 선택 잘하자..!
  - **우선 범위 좀 넘을 것 같으면 long으로 통일하자!**
- dp에는 여러 방식이 있을 수 있다!
  - **이차원 배열을 통해 이전 값을 더욱 세밀하게 활용하는 방법도 있다!**
  - 이전 값을 순차적으로 정적으로 활용하는 게 아니라, 경우의 수 나눠서 동적으로 활용하는 방법도 있음! (계단 오르기, 포도주 시식)
- answer += steps[n][i] % mod;
  - 이렇게 나누는 건 의미가 없다! 
  - 고친 코드: answer = (answer + steps[n][i]) % mod;

### [계단 오르기]
- 검토할 때 극단적인 경우, 값 고려하자!! 해당 문제에서 n이 1일 때, 런타임 에러 생길 수 있음.

### [포도주 시식]
- dp[i-3] 이런 것(인덱스 에러 유발) 때문에 처음에 초기화하는 부분 긴장 놓치지 말자! 꼼꼼히!
  - int i = 0부터 활용하는게 아니라 i=1부터 하면 그나마 앞 초기화 부분 줄일 수 있다!
- dp[i - 4] + drinks[i - 1] + drinks[i] 이거 고려할 필요 없음. dp[i-1]로 인해 알아서 고려됨.